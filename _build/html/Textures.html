<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Textures, Lights and Shaders &mdash; 3D Graphics with pi3d</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="3D Graphics with pi3d" href="index.html" />
    <link rel="next" title="Models" href="Models.html" />
    <link rel="prev" title="Shapes, Buffers and Display" href="Shapes.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Models.html" title="Models"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Shapes.html" title="Shapes, Buffers and Display"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">3D Graphics with pi3d</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="textures-lights-and-shaders">
<h1>Textures, Lights and Shaders<a class="headerlink" href="#textures-lights-and-shaders" title="Permalink to this headline">¶</a></h1>
<p>We&#8217;ve touched on the roles of these three classes previously but in this
chapter I hope to give much more detail of how they fit together and how
they can be used.</p>
<div class="section" id="textures">
<h2>Textures<a class="headerlink" href="#textures" title="Permalink to this headline">¶</a></h2>
<p>First of all have a look at the next illustration program textures01.py
and run it to see what it does. The code starts from 3D_matrices03.py but
replaces the yellow material of the cube with an image texture, the docstrings
explain the changes.</p>
</div>
<div class="section" id="lights">
<h2>Lights<a class="headerlink" href="#lights" title="Permalink to this headline">¶</a></h2>
<p>Before looking at the next texture example it would be good to get more of
an idea how Light works; so open up and run the light01.py example. Again,
much of the explanation that I would have put here is in the docstrings so
read them and try the experiments suggested in the text.</p>
<a class="reference internal image-reference" href="_images/texture02.png"><img alt="_images/texture02.png" class="align-right" src="_images/texture02.png" style="width: 118.75px; height: 115.0px;" /></a>
<p>Now work your way through textures02.py which is using all the functionality
available in the &#8220;standard&#8221; shaders. There are lots of variables to tweak
and experiments to do with this example so work your way though it slowly
and carefully.</p>
</div>
<div class="section" id="shaders">
<h2>Shaders<a class="headerlink" href="#shaders" title="Permalink to this headline">¶</a></h2>
<p>In the next illustration we will look at what the shader is doing to
a) look up the texture values for a given pixel b) adjust for lighting.
However the code to get the normal map and reflection map is rather
complicated so I will only give an outline description of that here (if you
want to look at it in detail you will have to read through the shader yourself!)</p>
<p><strong>Caution</strong> the language that shaders use (GLSL) is C-like in syntax, but
that in itself shouldn&#8217;t be a problem, the confusing aspect is that variables
can be &#8220;different shapes&#8221;. Bearing in mind that in GLSL (as in C) variable
types have to be explicitly defined:</p>
<div class="highlight-glsl"><div class="highlight"><pre><span class="k">float</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">4.12</span><span class="p">;</span>
<span class="k">vec2</span> <span class="n">b</span> <span class="o">=</span> <span class="k">vec2</span><span class="p">(</span><span class="mf">4.12</span><span class="p">,</span> <span class="mf">5.23</span><span class="p">);</span>
<span class="k">vec3</span> <span class="n">c</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">4.12</span><span class="p">,</span> <span class="mf">5.23</span><span class="p">,</span> <span class="mf">7.34</span><span class="p">);</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">3.1416</span><span class="p">);</span> <span class="c1">// python equivalent would be a % 3.1416</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mf">3.1416</span><span class="p">);</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mf">3.1416</span><span class="p">);</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="k">vec2</span><span class="p">(</span><span class="mf">3.1416</span><span class="p">,</span> <span class="mf">6.2832</span><span class="p">);</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">3.1416</span><span class="p">,</span> <span class="mf">6.2832</span><span class="p">,</span> <span class="mf">9.4248</span><span class="p">);</span>
</pre></div>
</div>
<p>You will see that generally speaking variables can be vectors which the compiled
GLSL is designed to process very fast. On the other hand branching and
conditional statements are very slow and this results in some non-standard
program structuring.</p>
<a class="reference internal image-reference" href="_images/dot_eg.png"><img alt="_images/dot_eg.png" class="align-left" src="_images/dot_eg.png" style="width: 200.0px; height: 200.0px;" /></a>
<p>One final bit of explanation before looking at the next example. The dot
product of two vectors is often described as &#8220;the length of one times the
length of the other times the cosine of the angle between them&#8221;. This is
reasonably easy to apprehend in two dimensions, and when we can think of
the vectors as arrows. However in four dimension when the vectors represent
RGBA values it&#8217;s not so intuitive. A better informal description would be
&#8220;how much of one vector is in the same direction as the other&#8221; it&#8217;s still
easy to see how this applies to light illuminating a surface but it&#8217;s much
easier to see that the dot function doesn&#8217;t need to do any (slow) trigonometry,
it is sufficient to multiply the x,y,z components together and this is very
fast:</p>
<div class="highlight-glsl"><div class="highlight"><pre><span class="n">normal</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>   <span class="c1">// surface facing in the same direction as x axis</span>
<span class="n">light</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.5</span><span class="p">);</span> <span class="c1">// light down, from right, out of the screen</span>
<span class="k">float</span> <span class="n">a</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">light</span><span class="p">);</span>   <span class="c1">// results in -2.5 # i.e. (1.0 * -2.5) + (0.0 * -2.5) + (0.0 * 2.5)</span>
</pre></div>
</div>
<p>So now have a look at shader01.py and play around with it. Any typos or
errors in the two shader scripts will be hard to track down so proceed with
caution (remember Ctrl-z can get you back to a working version!). Also,
because the GLSL is embedded in strings in the python code, the chances
are that any code formatting in your editor will not be brilliant, so here
is the code again. Vertex Shader:</p>
<div class="highlight-glsl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">precision</span> <span class="k">mediump</span> <span class="k">float</span><span class="p">;</span>
<span class="k">attribute</span> <span class="k">vec3</span> <span class="n">vertex</span><span class="p">;</span>           <span class="c1">// these are the array buffer objects defined in Buffer</span>
<span class="k">attribute</span> <span class="k">vec3</span> <span class="n">normal</span><span class="p">;</span>
<span class="k">attribute</span> <span class="k">vec2</span> <span class="n">texcoord</span><span class="p">;</span>

<span class="k">uniform</span> <span class="k">mat4</span> <span class="n">modelviewmatrix</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// [0] model movement in real coords, [1] in camera coords</span>
<span class="k">uniform</span> <span class="k">vec3</span> <span class="n">unib</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="cm">/* umult, vmult =&gt; unib[2][0:1] # these are defined in Buffer</span>
<span class="cm">   u_off, v_off =&gt; unib[3][0:1] */</span>
<span class="k">uniform</span> <span class="k">vec3</span> <span class="n">unif</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="cm">/* eye position =&gt; unif[6][0:3] # defined in Shape</span>
<span class="cm"> light position =&gt; unif[8][0:3] */</span>

<span class="k">varying</span> <span class="k">vec2</span> <span class="n">texcoordout</span><span class="p">;</span> <span class="c1">// these have values set in the vertex shader which</span>
<span class="k">varying</span> <span class="k">vec3</span> <span class="n">lightVector</span><span class="p">;</span> <span class="c1">// are picked up in the fragment shader. However</span>
<span class="k">varying</span> <span class="k">float</span> <span class="n">lightFactor</span><span class="p">;</span><span class="c1">// their values &quot;vary&quot; by interpolating between vertices</span>
<span class="k">varying</span> <span class="k">vec3</span> <span class="n">normout</span><span class="p">;</span>

<span class="k">void</span> <span class="n">main</span><span class="p">(</span><span class="k">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">vec4</span> <span class="n">relPosn</span> <span class="o">=</span> <span class="n">modelviewmatrix</span><span class="p">[</span><span class="mo">0</span><span class="p">]</span> <span class="o">*</span> <span class="k">vec4</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">unif</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mo">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>                        <span class="c1">// this is a point light and unif[8] is location</span>
    <span class="n">lightVector</span> <span class="o">=</span>  <span class="n">unif</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">-</span> <span class="k">vec3</span><span class="p">(</span><span class="n">relPosn</span><span class="p">);</span>
    <span class="n">lightFactor</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">lightVector</span><span class="p">),</span> <span class="o">-</span><span class="mf">2.0</span><span class="p">);</span> <span class="c1">// inverse square law</span>
    <span class="n">lightVector</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightVector</span><span class="p">);</span>         <span class="c1">// now convert to unit vector for direction</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                        <span class="c1">// this is directional light</span>
    <span class="n">lightVector</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">unif</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span> <span class="o">*</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>      <span class="c1">// directional light</span>
    <span class="n">lightFactor</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">lightVector</span><span class="p">.</span><span class="n">z</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>                          <span class="c1">// fix r-hand axis</span>
  <span class="n">normout</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="k">vec3</span><span class="p">(</span><span class="n">modelviewmatrix</span><span class="p">[</span><span class="mo">0</span><span class="p">]</span> <span class="o">*</span> <span class="k">vec4</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)));</span> <span class="c1">// matrix multiplication</span>
  <span class="n">texcoordout</span> <span class="o">=</span> <span class="n">texcoord</span> <span class="o">*</span> <span class="n">unib</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">xy</span> <span class="o">+</span> <span class="n">unib</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">xy</span><span class="p">;</span> <span class="c1">// offset and mult for texture coords</span>

  <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">modelviewmatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="k">vec4</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span><span class="mf">1.0</span><span class="p">);</span> <span class="c1">// matrix multiplication</span>
                                  <span class="c1">// NB now including projection as well as model movement</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>and Fragment shader:</p>
<div class="highlight-glsl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">precision</span> <span class="k">mediump</span> <span class="k">float</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">sampler2D</span> <span class="n">tex0</span><span class="p">;</span> <span class="c1">// this is the texture object</span>
<span class="k">uniform</span> <span class="k">vec3</span> <span class="n">unib</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="cm">/*     blend cutoff =&gt; unib[0][2] # defined in Buffer */</span>
<span class="k">uniform</span> <span class="k">vec3</span> <span class="n">unif</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="cm">/*      shape alpha =&gt; unif[5][2] # defined in Shape</span>
<span class="cm">          light RGB =&gt; unif[9][0:3]</span>
<span class="cm">  light ambient RGB =&gt; unif[10][0:3] */</span>


<span class="k">varying</span> <span class="k">vec3</span> <span class="n">normout</span><span class="p">;</span> <span class="c1">// as sent from vertex shader</span>
<span class="k">varying</span> <span class="k">vec2</span> <span class="n">texcoordout</span><span class="p">;</span>
<span class="k">varying</span> <span class="k">vec3</span> <span class="n">lightVector</span><span class="p">;</span>
<span class="k">varying</span> <span class="k">float</span> <span class="n">lightFactor</span><span class="p">;</span>

<span class="k">void</span> <span class="n">main</span><span class="p">(</span><span class="k">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">vec4</span> <span class="n">texc</span> <span class="o">=</span> <span class="n">texture2D</span><span class="p">(</span><span class="n">tex0</span><span class="p">,</span> <span class="n">texcoordout</span><span class="p">);</span> <span class="c1">// look up material or basic colour from texture</span>
  <span class="c1">//vec4 texc = vec4(0.7, 0.1, 0.4, 0.9);   // try making it a &quot;material&quot; color by swapping with the line above</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">texc</span><span class="p">.</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">unib</span><span class="p">[</span><span class="mo">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="k">discard</span><span class="p">;</span>         <span class="c1">// to allow rendering behind the transparent parts of this object</span>
  <span class="k">float</span> <span class="n">intensity</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">lightVector</span><span class="p">,</span> <span class="n">normout</span><span class="p">)</span> <span class="o">*</span> <span class="n">lightFactor</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> <span class="c1">// adjustment of colour according to combined normal</span>
  <span class="n">texc</span><span class="p">.</span><span class="n">rgb</span> <span class="o">=</span> <span class="p">(</span><span class="n">texc</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">unif</span><span class="p">[</span><span class="mi">9</span><span class="p">])</span> <span class="o">*</span> <span class="n">intensity</span> <span class="o">+</span> <span class="p">(</span><span class="n">texc</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">unif</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span> <span class="c1">// directional lightcol * intensity + ambient lightcol</span>

  <span class="n">gl_FragColor</span> <span class="o">=</span>  <span class="n">texc</span><span class="p">;</span>
  <span class="n">gl_FragColor</span><span class="p">.</span><span class="n">a</span> <span class="o">*=</span> <span class="n">unif</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>There is a khronos GLSL quick reference card <a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
<p>I mentioned above that I would give a general description of how the normal
map and reflection map work. If you have attempted to look at the shader
code &#8220;really&#8221; used in pi3d you will have found that it is structured with
lots of #includes so that common sections can be re-used - this makes it quite
hard to reconstruct. You may have also seen that the normal vector is not
passed from the vertex to fragment shader as shown in this example. Instead
the light vector is rotated in the vertex shader by a complicated process
(Euler angles again) so that it is correctly oriented relative to the normal
vector at that vertex <em>if that vector was pointing straight out of the screen</em>
i.e. in the -ve z direction!</p>
<p>The reason for this complication is that it then allows the fragment shader
to modify the normal vector by simply adding values from the RGB of a
normal map texture. Values of red less than 0.5 make the x component
of the normal negative, greater than 0.5 positive. The green values
control the y component in a similar way.</p>
<p>The reflection map works out the vertical and horizontal angles that a line
drawn from the camera to a given pixel would be reflected. The reflection
uses the normal vector at each pixel adjusted by the normal map as described
above. The reflection angles are then used to look up a position from a
Texture where the horizontal range is -pi to +pi (+/- 180 degrees) and the
vertical range is -pi/2 to +pi/2 (+/- 90 degrees) This is the standard
projection used for photo-spheres.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="https://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf">https://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Textures, Lights and Shaders</a><ul>
<li><a class="reference internal" href="#textures">Textures</a></li>
<li><a class="reference internal" href="#lights">Lights</a></li>
<li><a class="reference internal" href="#shaders">Shaders</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="Shapes.html"
                        title="previous chapter">Shapes, Buffers and Display</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="Models.html"
                        title="next chapter">Models</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/Textures.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Models.html" title="Models"
             >next</a> |</li>
        <li class="right" >
          <a href="Shapes.html" title="Shapes, Buffers and Display"
             >previous</a> |</li>
        <li><a href="index.html">3D Graphics with pi3d</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Paddy Gaunt.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>